# MCP 활용 사례 및 실제 프롬프트 구조 분석

## VSCode에서의 MCP 실전 사례

Visual Studio Code(이하 VSCode)는 MCP를 지원하는 대표적인 애플리케이션(호스트)입니다. 2024년에 VSCode에 에이전트 모드(Agent Mode) 기능이 도입되면서, Copilot 등의 AI가 개발자의 워크스페이스에 대한 맥락을 더 잘 이해하고 작업을 자동화할 수 있게 되었습니다. VSCode는 이때 MCP 프로토콜을 채택하여, 다양한 MCP 서버들을 플러그인처럼 추가할 수 있는 구조를 갖추었습니다.

### 사용 시나리오: 

예를 들어 VSCode에서 **파일시스템 MCP 서버**와 **GitHub MCP 서버**를 사용하도록 설정했다고 가정해 봅시다: 

- 로컬 파일 시스템 MCP 서버: VSCode 확장을 통해 로컬에 ```filesystem``` MCP 서버를 실행하면, AI는 프로젝트 디렉토리의 파일을 읽거나 검색하는 **리소스/툴**을 획득합니다. (예: ```resources```로 파일 리스트 제공, ```read_file``` 툴 또는 ```search_in_files``` 툴 등). 

- GitHub MCP 서버: GitHub에서 제공하는 원격 MCP 서버에 연결하면, ***원격 저장소와 이슈/PR 관리**에 대한 툴을 얻습니다. (예: ```list_repos```, ```create_pull_request```, ```add_issue_comment``` 등의 툴이 노출될 수 있습니다). 

- 기타 서버: 사용자는 필요에 따라 Database MCP 서버(MySQL/Postgres), Web 검색 MCP 서버, 타사 API MCP 서버 등을 VSCode에 추가할 수 있습니다.

### VSCode MCP 설정: 

VSCode에서는 MCP 서버를 추가하기 위해 ***커맨드 팔레트***에서 ```MCP: Browse Servers``` 명령을 사용하거나, 워크스페이스 폴더에 ```.vscode/mcp.json``` 파일을 작성할 수 있습니다. 예를 들어, GitHub MCP 서버를 워크스페이스에 설정하는 ```mcp.json``` 예시는 다음과 같습니다:

```json
{
  "servers": {
    "github": {
      "type": "http",
      "url": "https://api.githubcopilot.com/mcp",
      "authorization": "bearer ${env:GITHUB_TOKEN}"
    }
  }
}
```

이 설정을 추가하면 VSCode는 **GitHub MCP 서버**에 연결하여 툴 목록을 가져옵니다. **연결 시 처음 한 번 신뢰 여부**를 묻는데, 이는 MCP 서버가 사용자 컴퓨터에서 코드 실행 등의 강력한 작업을 할 수 있으므로 **신뢰할 수 있는 서버만 추가해야 함**을 상기시켜 줍니다.

### MCP 서버 사용 in VSCode

설정이 완료되면, VSCode의 Copilot Chat(또는 유사한 에이전트 창)이 활성화된 MCP 툴들을 활용할 수 있게 됩니다. 사용자는 자연어로 명령을 내리고, AI는 필요한 경우 MCP 툴을 호출하여 작업을 수행합니다. 

예를 들어: 

- "이 프로젝트의 README 내용을 요약해줘."라고 사용자 요청 → AI는 ```filesystem``` MCP 서버의 ```resources/list```로 README 파일을 찾고, ```resources/read```로 내용을 가져온 뒤 요약 답변을 생성. 

- "현재 프로젝트를 새로운 깃 리포지토리에 올려줘." 요청 → AI는 GitHub MCP 서버의 ```create_repo``` 툴을 호출하고, ```push_code``` 툴을 순차적으로 호출하여, 결과로 GitHub에 새 저장소를 만들고 코드를 업로드. 

- "버그 발생 로그를 확인하고 이슈 생성해줘." 요청 → AI는 Sentry MCP 서버(예시)에서 에러 로그 데이터를 ```resources/read```로 얻고, 분석 후 GitHub MCP 서버의 ```create_issue``` 툴을 호출하여 요약된 버그 리포트를 이슈로 등록.

이러한 과정을 거치는 동안 VSCode UI에서는 **툴 사용 내역**을 표시해 줍니다. 예컨대 AI가 파일을 열람하면 "🤖 read_file: README.md" 같은 로그를, 깃헙 이슈를 만들면 "🤖 create_issue: Bug report created" 같은 메시지를 볼 수 있습니다. VSCode는 사용자가 이해할 수 있도록 툴 실행 전 **승인**을 요구하기도 합니다 (보안 상 자동 실행을 막기 위해).

**실전 팁**: VSCode에서 MCP 서버를 2개 이상 연결하면, AI는 다중 도구 에이전트로 거듭납니다. 이때 어떤 툴을 언제 쓸지는 모델이 프롬프트 맥락에서 판단하지만, 개발자는 **시스템 메시지** 등을 통해 힌트를 줄 수 있습니다. (예: "You have access to the following tools: ..."). VSCode Copilot는 이러한 프롬프트를 자동 관리해주기 때문에 사용자는 명령만 하면 됩니다.

결론적으로 VSCode에서 MCP를 활용하면, AI 코딩 비서가 **IDE의 다양한 기능+클라우드 서비스를 아우르는 조력자**가 됩니다. 이는 개발 경험을 크게 향상시켜주며, MCP가 실제 현업 도구에 접목된 좋은 사례입니다.

## MCP Prompts, Resources, Tools 실전 예시

이제 MCP의 세 가지 핵심 요소인 프롬프트, 리소스, 툴을 실제 사례를 통해 조금 더 자세히 들여다보겠습니다. 각각의 요소는 AI 에이전트가 **컨텍스트를 받고 행동**하는 방식을 다르게 지원합니다:

### Tools (툴) 예시 – 계산기 툴:

가령 간단한 **계산기 MCP 서버**를 설계한다고 해봅시다. 이 서버는 두 숫자의 합을 구해주는 ```add_numbers``` 라는 툴 하나만 노출합니다.

**툴 정의**: 이름은 ```"add_numbers"```, 설명은 ```"두 숫자의 합을 반환"```, inputSchema는 a와 b 두 숫자를 받고, outputSchema는 결과 숫자를 반환하도록 합니다. 툴 메타데이터 JSON은 다음과 같을 것입니다:

```json
{
    "name": "add_numbers",
    "title": "Add Two Numbers",
    "description": "두 개의 숫자를 더하여 합계를 반환합니다",
    "inputSchema": {
        "type": "object",
            "properties": {
                "a": { "type": "number", "description": "첫 번째 숫자" },
                "b": { "type": "number", "description": "두 번째 숫자" }
        },
        "required": ["a", "b"]
    },
    "outputSchema": {
        "type": "number",
        "description": "a와 b를 더한 결과"
    }
}
```

서버는 초기화 시 이 툴을 클라이언트에 알릴 것이고, 클라이언트 ```tools/list``` 요청 시 위 정보가 전달됩니다. 사용자가 "3과 5를 더하면 얼마야?"라고 질문하면, AI 모델은 이 요청을 이해하고 **툴 사용이 필요**하다고 판단할 것입니다.

툴 호출 예시 대화:
- User: "3과 5를 더하면 얼마인가요?"
- Assistant (내부 판단): 이건 계산이 필요하니 ```add_numbers``` 툴을 써야겠다.
- Assistant → (호스트를 통해 MCP 요청): ```tools/call``` (```name```: add_numbers, ```arguments```: {a:3, b:5})
- MCP Server → 응답: 결과 8 반환.
- Assistant ← 결과 기반 답변: "3과 5를 더하면 8입니다."

이 과정에서 사용자는 툴이 쓰였는지 직접 볼 수도 있고 모를 수도 있지만, 핵심은 **모델 스스로 연산을 하지 않고 MCP 툴을 통해 정확한 결과를 얻는다**는 점입니다. 특히 수학 계산, 날짜 변환, 데이터베이스 질의 등 **정확성이 요구**되거나 **모델 지식에 없는 정보**는 이렇게 **MCP 툴로 해결**할 수 있습니다.

### Resources (리소스) 예시 – 문서 요약:

한편, 리소스는 툴과 달리 **수동적 컨텍스트**를 제공합니다. 예를 들어 **사내 위키 문서**를 MCP 리소스로 연동해놓았다면, 사용자는 "우리 회사 휴가 정책 알려줘"라고 물을 때 AI가 관련 문서를 읽고 답할 수 있습니다.

**리소스 준비**: HR 정책이 적힌 PDF를 텍스트로 변환해 ```policies/vacation_policy.txt```로 MCP 서버에 올려두었다고 합시다. 서버는 이 파일을 리소스로 공개하고 ```resources/list```에 해당 URI와 설명("휴가 정책 문서")을 포함시킵니다.

**AI 응답 과정**: 사용자가 질문하면, AI는 자체 지식만으로 확신이 없을 경우 MCP 클라이언트에 **리소스 검색**을 요청할 수 있습니다. (일부 고급 호스트는 사용자의 질문을 벡터임베딩으로 변환해 관련 리소스를 추천해주는 기능도 있습니다.) 
이 경우:

- Assistant → ```resources/list``` (필요시 필터) → 서버 응답으로 여러 리소스 중 "휴가 정책" 관련 발견.
- Assistant → ```resources/read``` (해당 URI) → 서버가 문서 내용 반환.
- Assistant ← 문서 내용 기반으로 요약 생성: "우리 회사의 휴가 정책은 연 15일의 연차 휴가를 제공하며, ...".

리소스는 이처럼 **모델에게 배경지식을 주입**하는 역할을 합니다. 모델이 직접 텍스트를 봤기 때문에 인용 형태로 답변하거나, 정확한 수치/규정을 답변할 수 있습니다. 
한편, VSCode 같은 호스트에서는 사용자가 채팅창 옆에서 현재 대화에 포함시킬 리소스를 선택할 수도 있습니다 (예: 관련 파일을 컨텍스트로 추가). 이것이 MCP 리소스의 사용자 제어형 활용 예입니다.

### Prompts (프롬프트) 예시 – 템플릿 활용:
프롬프트 템플릿은 반복되는 질의나 복잡한 요청을 **간소화**해주는 역할을 합니다. 가령 프로그래밍 도메인에서 "코드 리뷰", "리팩토링 제안", "버그 찾기" 같은 작업은 자주 쓰이는데, 이를 MCP 서버가 프롬프트로 제공하면 사용자가 **한 두 클릭**으로 AI에게 복잡한 지시를 할 수 있습니다.

**예시**: 코드 리뷰 MCP 서버는 다음과 같은 프롬프트를 노출할 수 있습니다:
```json
{
    "name": "code_review",
    "title": "Request Code Review",
    "description": "선택한 코드에 대한 품질 분석과 개선 사항 제안을 요청합니다.",
    "arguments": [
        { 
            "name": "code", 
            "description": "리뷰할 코드 (텍스트)", 
            "required": true 
        }
    ]
}
```

사용자가 VSCode에서 함수 코드를 드래그한 후 "Request Code Review" 프롬프트를 선택하면, VSCode는 해당 코드 텍스트를 ```code``` 인자에 넣어 ```prompts/get```을 호출합니다. 서버는 미리 준비된 템플릿(예: ```"다음 코드를 리뷰해줘:\n\n{{code}}"```)에 실제 코드를 채워 messages를 생성하고, AI에게 전달합니다. 결과적으로 사용자는 직접 "이러이러한 기준으로 리뷰해줘"라고 길게 프롬프트 작성하지 않아도, **일관된 형식의 지시**를 AI에게 내릴 수 있게 됩니다. 

AI 모델 측에서도 매번 프롬프트가 일정한 구조이므로, 리뷰 결과를 체계적으로 반환하기 수월해집니다 (예: 항상 코드에 대한 총평, 개선사항 목록, 잠재 버그 언급 등 일정한 패턴으로 답변하도록 튜닝 가능).

이처럼 프롬프트 MCP 기능은 **자주 쓰는 복잡 질의를 캡슐화**함으로써 사용자 생산성을 높입니다. 특히 비개발자 사용자를 위한 챗봇 인터페이스에서 슬래시 명령이나 버튼으로 제공될 때 유용합니다. (예: "/분석 보고서 생성" 프롬프트를 누르면 자동으로 데이터 분석용 질문 템플릿을 생성해주는 등.)

정리하면, **Tools**는 모델의 **행동 범위**를 넓히고, **Resources**는 모델의 **지식 범위**를 확장하며, **Prompts**는 **사용자-모델 상호작용 패턴을 최적화**하는 역할을 합니다. 세 요소는 MCP 서버에 따라 하나만 제공되기도 하고, 둘 이상을 조합하기도 합니다. 예를 들어 파일시스템 서버는 주로 리소스와 몇 가지 툴(파일 검색 등)을 제공하고, GitHub 서버는 툴 위주이며, 어떤 서버는 프롬프트만 제공하기도 합니다. **MCP 클라이언트**(**호스트**)는 이 모든 정보를 종합하여 모델이 최적의 답변을 하도록 돕습니다.

## Prompt/Tool JSON 설계 실습

간단한 MCP JSON 설계 실습을 해보겠습니다. 여러분이 MCP 서버 측을 설계한다는 관점에서, 하나의 툴과 하나의 프롬프트를 직접 정의해보는 예제입니다. 이를 통해 MCP 스키마 구조에 익숙해지는 것이 목표입니다.

### 실습 예제 1: 툴 JSON 설계

가정: 영화 정보 검색 MCP 서버를 만들려고 합니다. 이 서버에는 외부 영화 API를 호출하여 정보를 가져오는 툴이 하나 있습니다. 툴 사양은 다음과 같습니다: 

- 이름: ```movie_search```
- 기능: 영화 제목을 입력 받아 해당 영화의 개요(plot)와 개봉연도를 반환.
- 입력: 영화 제목 (```title```: string, 필수)
- 출력: 영화 제목, 개봉연도, 줄거리로 구성된 객체.

이 요구사항을 JSON 툴 정의로 표현하면:
```json
{
    "name": "movie_search",
    "title": "Movie Info Search",
    "description": "입력한 영화의 개요와 개봉연도를 제공합니다.",
    "inputSchema": {
        "type": "object",
        "properties": {
            "title": { "type": "string", "description": "영화 제목" }
        },
        "required": ["title"]
    },
    "outputSchema": {
        "type": "object",
        "properties": {
            "title": { "type": "string", "description": "영화 제목" },
            "year":  { "type": "integer", "description": "개봉 연도" },
            "plot":  { "type": "string", "description": "줄거리" }
        }
    }
}
```

이렇게 정의된 툴을 MCP 서버가 구현할 때는, 실제로는 영화 API (예: OMDB API 등)를 호출하고, 응답 JSON을 위 출력 스키마에 맞게 가공하여 ```tools/call```의 결과로 반환하면 됩니다. MCP 클라이언트는 outputSchema를 참고하여 모델에게 결과를 전달하거나, 혹은 UI에서 특별 처리 없이 일단 JSON을 문자열로 모델에게 보내 모델이 적절히 답변에 포함시키도록 할 수 있습니다. (복잡한 구조의 output을 다루는 건 호스트에 따라 상이합니다. 단순히 텍스트로 풀어서 모델에게 주거나, 일부는 클라이언트가 후처리하기도 합니다.)

### 실습 예제 2: 프롬프트 JSON 설계

가정: 헬스 코칭 MCP 서버를 갖고 있습니다. 사용자가 매일 운동/식단 기록을 입력하면 AI가 건강 코멘트를 해주는 챗봇입니다. 여기에 ```"/오늘 요약 리포트"``` 라는 프롬프트를 추가하려고 합니다. 이 프롬프트는 사용자의 당일 운동/식단 데이터를 요약 분석해달라는 요청을 자동 생성합니다. 

프롬프트 사양: 
- 이름: ```daily_report```
- 기능: 오늘의 활동 데이터에 대한 요약 보고 요청 생성.
- 인자: 칼로리 섭취량 (```calories``` int), 운동 시간 (```exercise_minutes``` int). (이 둘을 사용자로부터 입력받아 프롬프트에 삽입)
- 생성 메시지: 사용자 역할 메시지로, 예시 - ```"오늘 나는 칼로리 ${calories}kcal를 섭취했고, 운동을 ${exercise_minutes}분 했어. 이 정보를 바탕으로 건강 상태를 요약해줘."```

이를 MCP 프롬프트 정의로 표현하면:
```json
{
    "name": "daily_report",
    "title": "오늘 요약 리포트",
    "description": "오늘의 운동/식단 기록을 요약 분석 요청",
    "arguments": [
        { "name": "calories", "description": "오늘 섭취한 칼로리(kcal)", "required": true },
        { "name": "exercise_minutes", "description": "오늘 운동 시간(분)", "required": true }
    ]
}
```

프롬프트 템플릿 내용은 MCP 서버 구현부에 있고, 클라이언트가 ```prompts/get```을 호출하면 서버는 해당 내용을 채워 메시지를 돌려줍니다. 예를 들어 사용자가 2000 kcal, 30분 운동 입력하면:

```json
{
    "jsonrpc": "2.0",
    "id": 7,
    "result": {
    "messages": [
        {
            "role": "user",
            "content": { 
                "type": "text", 
                "text": "오늘 나는 칼로리 2000kcal를 섭취했고, 운동을 30분 했어. 이 정보를 바탕으로 내 건강 상태를 요약해줘."
            }
        }
    ]
    }
}
```
이 메시지를 받은 AI는 해당 내용에 맞춰 응답하게 될 것입니다. 사용자는 직접 긴 문장을 적지 않고, 숫자 두 개만 입력해서 손쉽게 AI에게 요약을 요청할 수 있죠.

실습 결과 검토: 위의 툴과 프롬프트 JSON 설계 예시를 통해, MCP 정의가 **사람에게도 읽기 쉬운 자기문서화(self-documenting) 형태**임을 알 수 있습니다. 각 속성이 하는 일과 필요한 값들이 명확히 나열되므로, 훗날 서버를 추가하거나 수정할 때 이해가 쉽습니다. 또한 이러한 정의는 **SDK를 통해 클래스나 데코레이터 형태**로도 작성할 수 있지만, 기본 개념을 익히기 위해 JSON 포맷으로 연습해 보았습니다.

